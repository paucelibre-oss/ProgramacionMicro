/*
 * API_delay.c
 *
 *  Created on: Sep 21, 2025
 *      Author: Paulo
 */
/*
 *@brief Funcion para cargar valor del retardo no bloqueante.
 *@param delay_t* delay: puntero a struct delay_t.
 *@param tick_t duration: uint32 duración del delay en ms.
 *@retval None
 * */
#include "../Inc/API_delay.h"

#define DELAY_DURATION		40

typedef enum{
	BUTTON_UP,
	BUTTON_FALLING,
	BUTTON_DOWN,
	BUTTON_RISING,
} debounceState_t;

static debounceState_t state = BUTTON_UP;
static delay_t myDelay;

static void buttonPressed();

static void buttonReleased();

/*
 *@brief Funcion para cargar valor del retardo no bloqueante.
 *@param delay_t* delay: puntero a struct delay_t.
 *@param tick_t duration: uint32 duración del delay en ms.
 *@retval None
 * */
void delayInit(delay_t * delay, tick_t duration)
{
	delay->duration = duration;
	delay->running = false;
	delay->startTime = (tick_t)(0);
}

/*
 *@brief Función para revisar el tiempo transcurrido del retardo.
 *@param delay_t* delay: puntero a struct delay_t
 *@retval True, si el el tiempo ya se cumplió
 *@retval False, para cualquier otro caso
 */
bool_t delayRead(delay_t * delay)
{
	if(!delay->running){
		delay->startTime = (tick_t)(HAL_GetTick());
		delay->running = true;
	}else{
		if(((tick_t)(HAL_GetTick()) - delay->startTime) >= delay->duration){
			delay->running = false;
			return true;
		}
	}

	return false;
}
/*
 *@brief Función para revisar el estado del retardo.
 *@param delay_t* delay: puntero a struct delay_t
 *@retval True, si se está corriendo un retardo
 *@retval False, para cualquier otro caso
 */
bool_t delayIsRunning(delay_t * delay) {
   return delay->running;
}
/*
 *@brief Función para cambiar el valor de la duración del delay
 *@param delay_t* delay: puntero a struct delay_t
 *@param tick_t duration: uint32 duración del delay en ms.
 *@retval None*/
void delayWrite(delay_t * delay, tick_t duration)
{
	delay->duration = duration;
	delay->running = false;
}

void debounceFSM_init()
{
	state = BUTTON_UP;
	HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
}// debe cargar el estado inicial

void debounceFSM_update()	// debe leer las entradas, resolver la lógica de transición de estados y actualizar las salidas
{

	switch(state){
		case BUTTON_UP:
			if( HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin) == GPIO_PIN_RESET){
				state = BUTTON_FALLING;
				delayInit(&myDelay, (tick_t)(DELAY_DURATION));
			}
			break;
		case BUTTON_FALLING:
			if(delayRead(&myDelay)){
				if( HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin) == GPIO_PIN_RESET){
					state = BUTTON_DOWN;
					buttonPressed();
				}else state = BUTTON_UP;
			}
			break;
		case BUTTON_DOWN:
			if( HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin) == GPIO_PIN_SET){
				state = BUTTON_RISING;
				delayInit(&myDelay, (tick_t)(DELAY_DURATION));
			}
			break;
		case BUTTON_RISING:
			if(delayRead(&myDelay)){
				if( HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin) == GPIO_PIN_SET){
					state = BUTTON_UP;
					buttonReleased();
				}
			}
			break;
		default:
			debounceFSM_init();
			break;
	}
}

static void buttonPressed()			// debe encender el LED
{
	HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_SET);
}

static void buttonReleased()		// debe apagar el LED
{
	HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
}


